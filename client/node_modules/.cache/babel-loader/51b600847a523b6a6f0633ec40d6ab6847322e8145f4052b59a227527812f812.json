{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Dravya\\\\Expression Tracker(Leela)\\\\Expression_Tracker\\\\client\\\\src\\\\components\\\\ImageCaptureComponent.jsx\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useState, useRef } from 'react';\n// import html2canvas from 'html2canvas';\n// import { uploadImages } from '../services/api.js';\n\n// const ImageCapture = ({ sessionId, isActive }) => {\n//     const [screenshot, setScreenshot] = useState(null);\n//     const [webcamImage, setWebcamImage] = useState(null);\n//     const videoRef = useRef(null);\n//     const capturingRef = useRef(false);\n//     const[sessionId,setSessionId]=useState(null);\n//     const streamRef = useRef(null);\n\n//     // Function to capture a screenshot\n//     const captureScreenshot = async () => {\n//         const canvas = await html2canvas(document.body);\n//         canvas.toBlob(blob => {\n//             const file = new File([blob], 'screenshot.png', { type: 'image/png' });\n//             setScreenshot(file);\n//         }, 'image/png');\n//     };\n\n//     // Function to capture webcam image\n//     const captureWebcamImage = () => {\n//         if (videoRef.current) {\n//             const canvas = document.createElement('canvas');\n//             canvas.width = videoRef.current.videoWidth;\n//             canvas.height = videoRef.current.videoHeight;\n//             const ctx = canvas.getContext('2d');\n//             ctx.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\n//             canvas.toBlob(blob => {\n//                 const file = new File([blob], 'webcam.png', { type: 'image/png' });\n//                 setWebcamImage(file);\n//             }, 'image/png');\n//         }\n//     };\n\n//     // Single capture handler to avoid multiple triggers\n//     const captureImages = () => {\n//         if (!capturingRef.current && isActive) {\n//             capturingRef.current = true;\n//             captureScreenshot();\n//             captureWebcamImage();\n//             setTimeout(() => {\n//                 capturingRef.current = false;\n//             }, 1000);\n//         }\n//     };\n\n//     // Upload images when both are ready\n//     useEffect(() => {\n//         const upload = async () => {\n//             if (screenshot && webcamImage && sessionId && isActive) {\n//                 try {\n//                     await uploadImages(screenshot, webcamImage, sessionId);\n//                     console.log('Images uploaded successfully');\n//                     setScreenshot(null);\n//                     setWebcamImage(null);\n//                 } catch (error) {\n//                     console.error('Error uploading images:', error);\n//                 }\n//             }\n//         };\n//         upload();\n//     }, [screenshot, webcamImage, sessionId, isActive]);\n\n//     // Start/stop webcam based on isActive prop\n//     useEffect(() => {\n//         const startWebcam = async () => {\n//             if (isActive) {\n//                 try {\n//                     const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n//                     streamRef.current = stream;\n//                     if (videoRef.current) {\n//                         videoRef.current.srcObject = stream;\n//                     }\n//                 } catch (error) {\n//                     console.error('Error accessing webcam:', error);\n//                 }\n//             }\n//         };\n\n//         const stopWebcam = () => {\n//             if (streamRef.current) {\n//                 const tracks = streamRef.current.getTracks();\n//                 tracks.forEach(track => track.stop());\n//                 streamRef.current = null;\n//                 if (videoRef.current) {\n//                     videoRef.current.srcObject = null;\n//                 }\n//             }\n//         };\n\n//         if (isActive) {\n//             startWebcam();\n//         } else {\n//             stopWebcam();\n//         }\n\n//         return () => {\n//             stopWebcam();\n//         };\n//     }, [isActive]);\n\n//     // Set up/clear interval based on isActive prop\n//     useEffect(() => {\n//         let intervalId;\n\n//         if (isActive) {\n//             intervalId = setInterval(() => {\n//                 captureImages();\n//             }, 5000);\n//         }\n\n//         return () => {\n//             if (intervalId) {\n//                 clearInterval(intervalId);\n//             }\n//         };\n//     }, [isActive]);\n\n//     return (\n//         <div>\n//             <video ref={videoRef} autoPlay style={{ display: 'none' }} />\n//         </div>\n//     );\n// };\n\n// export default ImageCapture;\n\n// ImageCaptureComponent.jsx\nimport React, { useEffect, useRef, useState } from 'react';\nimport html2canvas from 'html2canvas';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ImageCapture = ({\n  sessionId,\n  isActive\n}) => {\n  _s();\n  const videoRef = useRef(null);\n  const capturingRef = useRef(false);\n  const [stream, setStream] = useState(null);\n  useEffect(() => {\n    let captureInterval;\n    const startCapture = async () => {\n      try {\n        const mediaStream = await navigator.mediaDevices.getUserMedia({\n          video: {\n            width: {\n              ideal: 640\n            },\n            height: {\n              ideal: 480\n            }\n          }\n        });\n        setStream(mediaStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = mediaStream;\n        }\n      } catch (error) {\n        console.error('Error accessing webcam:', error);\n      }\n    };\n    const stopCapture = () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n      if (captureInterval) {\n        clearInterval(captureInterval);\n      }\n    };\n    const captureAndUpload = async () => {\n      if (!capturingRef.current && sessionId) {\n        capturingRef.current = true;\n        try {\n          // Capture webcam\n          const webcamCanvas = document.createElement('canvas');\n          webcamCanvas.width = videoRef.current.videoWidth;\n          webcamCanvas.height = videoRef.current.videoHeight;\n          const webcamCtx = webcamCanvas.getContext('2d');\n          webcamCtx.drawImage(videoRef.current, 0, 0);\n\n          // Capture screenshot\n          const screenCanvas = await html2canvas(document.body, {\n            scale: 0.5,\n            // Reduce resolution for better performance\n            logging: false,\n            useCORS: true,\n            ignoreElements: element => {\n              return element.tagName === 'VIDEO';\n            }\n          });\n\n          // Convert to blobs with compression\n          const webcamBlob = await new Promise(resolve => webcamCanvas.toBlob(resolve, 'image/jpeg', 0.7));\n          const screenBlob = await new Promise(resolve => screenCanvas.toBlob(resolve, 'image/jpeg', 0.7));\n\n          // Create FormData and upload\n          const formData = new FormData();\n          formData.append('webcam', new File([webcamBlob], `webcam_${Date.now()}.jpg`, {\n            type: 'image/jpeg'\n          }));\n          formData.append('screenshot', new File([screenBlob], `screenshot_${Date.now()}.jpg`, {\n            type: 'image/jpeg'\n          }));\n          const response = await fetch(`http://localhost:5000/upload?sessionId=${sessionId}`, {\n            method: 'POST',\n            body: formData\n          });\n          if (!response.ok) {\n            throw new Error(`Upload failed: ${response.statusText}`);\n          }\n        } catch (error) {\n          console.error('Error capturing/uploading images:', error);\n        } finally {\n          capturingRef.current = false;\n        }\n      }\n    };\n    if (isActive && sessionId) {\n      startCapture();\n      captureInterval = setInterval(captureAndUpload, 5000); // Capture every 5 seconds\n    }\n    return () => {\n      stopCapture();\n    };\n  }, [sessionId, isActive, stream]);\n  return /*#__PURE__*/_jsxDEV(\"video\", {\n    ref: videoRef,\n    autoPlay: true,\n    playsInline: true,\n    muted: true,\n    style: {\n      display: 'none'\n    },\n    \"data-testid\": \"webcam-video\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 237,\n    columnNumber: 5\n  }, this);\n};\n_s(ImageCapture, \"fxuZrWJVMMneK/gjULsY31+uBgc=\");\n_c = ImageCapture;\nexport default ImageCapture;\nvar _c;\n$RefreshReg$(_c, \"ImageCapture\");","map":{"version":3,"names":["React","useEffect","useRef","useState","html2canvas","jsxDEV","_jsxDEV","ImageCapture","sessionId","isActive","_s","videoRef","capturingRef","stream","setStream","captureInterval","startCapture","mediaStream","navigator","mediaDevices","getUserMedia","video","width","ideal","height","current","srcObject","error","console","stopCapture","getTracks","forEach","track","stop","clearInterval","captureAndUpload","webcamCanvas","document","createElement","videoWidth","videoHeight","webcamCtx","getContext","drawImage","screenCanvas","body","scale","logging","useCORS","ignoreElements","element","tagName","webcamBlob","Promise","resolve","toBlob","screenBlob","formData","FormData","append","File","Date","now","type","response","fetch","method","ok","Error","statusText","setInterval","ref","autoPlay","playsInline","muted","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Dravya/Expression Tracker(Leela)/Expression_Tracker/client/src/components/ImageCaptureComponent.jsx"],"sourcesContent":["// import React, { useEffect, useState, useRef } from 'react';\r\n// import html2canvas from 'html2canvas';\r\n// import { uploadImages } from '../services/api.js';\r\n\r\n// const ImageCapture = ({ sessionId, isActive }) => {\r\n//     const [screenshot, setScreenshot] = useState(null);\r\n//     const [webcamImage, setWebcamImage] = useState(null);\r\n//     const videoRef = useRef(null);\r\n//     const capturingRef = useRef(false);\r\n//     const[sessionId,setSessionId]=useState(null);\r\n//     const streamRef = useRef(null);\r\n\r\n//     // Function to capture a screenshot\r\n//     const captureScreenshot = async () => {\r\n//         const canvas = await html2canvas(document.body);\r\n//         canvas.toBlob(blob => {\r\n//             const file = new File([blob], 'screenshot.png', { type: 'image/png' });\r\n//             setScreenshot(file);\r\n//         }, 'image/png');\r\n//     };\r\n\r\n//     // Function to capture webcam image\r\n//     const captureWebcamImage = () => {\r\n//         if (videoRef.current) {\r\n//             const canvas = document.createElement('canvas');\r\n//             canvas.width = videoRef.current.videoWidth;\r\n//             canvas.height = videoRef.current.videoHeight;\r\n//             const ctx = canvas.getContext('2d');\r\n//             ctx.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\r\n//             canvas.toBlob(blob => {\r\n//                 const file = new File([blob], 'webcam.png', { type: 'image/png' });\r\n//                 setWebcamImage(file);\r\n//             }, 'image/png');\r\n//         }\r\n//     };\r\n\r\n//     // Single capture handler to avoid multiple triggers\r\n//     const captureImages = () => {\r\n//         if (!capturingRef.current && isActive) {\r\n//             capturingRef.current = true;\r\n//             captureScreenshot();\r\n//             captureWebcamImage();\r\n//             setTimeout(() => {\r\n//                 capturingRef.current = false;\r\n//             }, 1000);\r\n//         }\r\n//     };\r\n\r\n//     // Upload images when both are ready\r\n//     useEffect(() => {\r\n//         const upload = async () => {\r\n//             if (screenshot && webcamImage && sessionId && isActive) {\r\n//                 try {\r\n//                     await uploadImages(screenshot, webcamImage, sessionId);\r\n//                     console.log('Images uploaded successfully');\r\n//                     setScreenshot(null);\r\n//                     setWebcamImage(null);\r\n//                 } catch (error) {\r\n//                     console.error('Error uploading images:', error);\r\n//                 }\r\n//             }\r\n//         };\r\n//         upload();\r\n//     }, [screenshot, webcamImage, sessionId, isActive]);\r\n\r\n//     // Start/stop webcam based on isActive prop\r\n//     useEffect(() => {\r\n//         const startWebcam = async () => {\r\n//             if (isActive) {\r\n//                 try {\r\n//                     const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n//                     streamRef.current = stream;\r\n//                     if (videoRef.current) {\r\n//                         videoRef.current.srcObject = stream;\r\n//                     }\r\n//                 } catch (error) {\r\n//                     console.error('Error accessing webcam:', error);\r\n//                 }\r\n//             }\r\n//         };\r\n\r\n//         const stopWebcam = () => {\r\n//             if (streamRef.current) {\r\n//                 const tracks = streamRef.current.getTracks();\r\n//                 tracks.forEach(track => track.stop());\r\n//                 streamRef.current = null;\r\n//                 if (videoRef.current) {\r\n//                     videoRef.current.srcObject = null;\r\n//                 }\r\n//             }\r\n//         };\r\n\r\n//         if (isActive) {\r\n//             startWebcam();\r\n//         } else {\r\n//             stopWebcam();\r\n//         }\r\n\r\n//         return () => {\r\n//             stopWebcam();\r\n//         };\r\n//     }, [isActive]);\r\n\r\n//     // Set up/clear interval based on isActive prop\r\n//     useEffect(() => {\r\n//         let intervalId;\r\n        \r\n//         if (isActive) {\r\n//             intervalId = setInterval(() => {\r\n//                 captureImages();\r\n//             }, 5000);\r\n//         }\r\n\r\n//         return () => {\r\n//             if (intervalId) {\r\n//                 clearInterval(intervalId);\r\n//             }\r\n//         };\r\n//     }, [isActive]);\r\n\r\n//     return (\r\n//         <div>\r\n//             <video ref={videoRef} autoPlay style={{ display: 'none' }} />\r\n//         </div>\r\n//     );\r\n// };\r\n\r\n// export default ImageCapture;\r\n\r\n// ImageCaptureComponent.jsx\r\nimport React, { useEffect, useRef, useState } from 'react';\r\nimport html2canvas from 'html2canvas';\r\n\r\nconst ImageCapture = ({ sessionId, isActive }) => {\r\n  const videoRef = useRef(null);\r\n  const capturingRef = useRef(false);\r\n  const [stream, setStream] = useState(null);\r\n\r\n  useEffect(() => {\r\n    let captureInterval;\r\n\r\n    const startCapture = async () => {\r\n      try {\r\n        const mediaStream = await navigator.mediaDevices.getUserMedia({ \r\n          video: {\r\n            width: { ideal: 640 },\r\n            height: { ideal: 480 }\r\n          }\r\n        });\r\n        setStream(mediaStream);\r\n        if (videoRef.current) {\r\n          videoRef.current.srcObject = mediaStream;\r\n        }\r\n      } catch (error) {\r\n        console.error('Error accessing webcam:', error);\r\n      }\r\n    };\r\n\r\n    const stopCapture = () => {\r\n      if (stream) {\r\n        stream.getTracks().forEach(track => track.stop());\r\n      }\r\n      if (captureInterval) {\r\n        clearInterval(captureInterval);\r\n      }\r\n    };\r\n\r\n    const captureAndUpload = async () => {\r\n      if (!capturingRef.current && sessionId) {\r\n        capturingRef.current = true;\r\n        try {\r\n          // Capture webcam\r\n          const webcamCanvas = document.createElement('canvas');\r\n          webcamCanvas.width = videoRef.current.videoWidth;\r\n          webcamCanvas.height = videoRef.current.videoHeight;\r\n          const webcamCtx = webcamCanvas.getContext('2d');\r\n          webcamCtx.drawImage(videoRef.current, 0, 0);\r\n          \r\n          // Capture screenshot\r\n          const screenCanvas = await html2canvas(document.body, {\r\n            scale: 0.5, // Reduce resolution for better performance\r\n            logging: false,\r\n            useCORS: true,\r\n            ignoreElements: (element) => {\r\n              return element.tagName === 'VIDEO';\r\n            }\r\n          });\r\n          \r\n          // Convert to blobs with compression\r\n          const webcamBlob = await new Promise(resolve => \r\n            webcamCanvas.toBlob(resolve, 'image/jpeg', 0.7)\r\n          );\r\n          const screenBlob = await new Promise(resolve => \r\n            screenCanvas.toBlob(resolve, 'image/jpeg', 0.7)\r\n          );\r\n          \r\n          // Create FormData and upload\r\n          const formData = new FormData();\r\n          formData.append('webcam', new File(\r\n            [webcamBlob], \r\n            `webcam_${Date.now()}.jpg`, \r\n            { type: 'image/jpeg' }\r\n          ));\r\n          formData.append('screenshot', new File(\r\n            [screenBlob], \r\n            `screenshot_${Date.now()}.jpg`, \r\n            { type: 'image/jpeg' }\r\n          ));\r\n          \r\n          const response = await fetch(`http://localhost:5000/upload?sessionId=${sessionId}`, {\r\n            method: 'POST',\r\n            body: formData,\r\n          });\r\n\r\n          if (!response.ok) {\r\n            throw new Error(`Upload failed: ${response.statusText}`);\r\n          }\r\n        } catch (error) {\r\n          console.error('Error capturing/uploading images:', error);\r\n        } finally {\r\n          capturingRef.current = false;\r\n        }\r\n      }\r\n    };\r\n\r\n    if (isActive && sessionId) {\r\n      startCapture();\r\n      captureInterval = setInterval(captureAndUpload, 5000); // Capture every 5 seconds\r\n    }\r\n\r\n    return () => {\r\n      stopCapture();\r\n    };\r\n  }, [sessionId, isActive, stream]);\r\n\r\n  return (\r\n    <video\r\n      ref={videoRef}\r\n      autoPlay\r\n      playsInline\r\n      muted\r\n      style={{ display: 'none' }}\r\n      data-testid=\"webcam-video\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default ImageCapture;"],"mappings":";;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,OAAOC,WAAW,MAAM,aAAa;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEtC,MAAMC,YAAY,GAAGA,CAAC;EAAEC,SAAS;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAChD,MAAMC,QAAQ,GAAGT,MAAM,CAAC,IAAI,CAAC;EAC7B,MAAMU,YAAY,GAAGV,MAAM,CAAC,KAAK,CAAC;EAClC,MAAM,CAACW,MAAM,EAAEC,SAAS,CAAC,GAAGX,QAAQ,CAAC,IAAI,CAAC;EAE1CF,SAAS,CAAC,MAAM;IACd,IAAIc,eAAe;IAEnB,MAAMC,YAAY,GAAG,MAAAA,CAAA,KAAY;MAC/B,IAAI;QACF,MAAMC,WAAW,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;UAC5DC,KAAK,EAAE;YACLC,KAAK,EAAE;cAAEC,KAAK,EAAE;YAAI,CAAC;YACrBC,MAAM,EAAE;cAAED,KAAK,EAAE;YAAI;UACvB;QACF,CAAC,CAAC;QACFT,SAAS,CAACG,WAAW,CAAC;QACtB,IAAIN,QAAQ,CAACc,OAAO,EAAE;UACpBd,QAAQ,CAACc,OAAO,CAACC,SAAS,GAAGT,WAAW;QAC1C;MACF,CAAC,CAAC,OAAOU,KAAK,EAAE;QACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MACjD;IACF,CAAC;IAED,MAAME,WAAW,GAAGA,CAAA,KAAM;MACxB,IAAIhB,MAAM,EAAE;QACVA,MAAM,CAACiB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MACnD;MACA,IAAIlB,eAAe,EAAE;QACnBmB,aAAa,CAACnB,eAAe,CAAC;MAChC;IACF,CAAC;IAED,MAAMoB,gBAAgB,GAAG,MAAAA,CAAA,KAAY;MACnC,IAAI,CAACvB,YAAY,CAACa,OAAO,IAAIjB,SAAS,EAAE;QACtCI,YAAY,CAACa,OAAO,GAAG,IAAI;QAC3B,IAAI;UACF;UACA,MAAMW,YAAY,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;UACrDF,YAAY,CAACd,KAAK,GAAGX,QAAQ,CAACc,OAAO,CAACc,UAAU;UAChDH,YAAY,CAACZ,MAAM,GAAGb,QAAQ,CAACc,OAAO,CAACe,WAAW;UAClD,MAAMC,SAAS,GAAGL,YAAY,CAACM,UAAU,CAAC,IAAI,CAAC;UAC/CD,SAAS,CAACE,SAAS,CAAChC,QAAQ,CAACc,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;;UAE3C;UACA,MAAMmB,YAAY,GAAG,MAAMxC,WAAW,CAACiC,QAAQ,CAACQ,IAAI,EAAE;YACpDC,KAAK,EAAE,GAAG;YAAE;YACZC,OAAO,EAAE,KAAK;YACdC,OAAO,EAAE,IAAI;YACbC,cAAc,EAAGC,OAAO,IAAK;cAC3B,OAAOA,OAAO,CAACC,OAAO,KAAK,OAAO;YACpC;UACF,CAAC,CAAC;;UAEF;UACA,MAAMC,UAAU,GAAG,MAAM,IAAIC,OAAO,CAACC,OAAO,IAC1ClB,YAAY,CAACmB,MAAM,CAACD,OAAO,EAAE,YAAY,EAAE,GAAG,CAChD,CAAC;UACD,MAAME,UAAU,GAAG,MAAM,IAAIH,OAAO,CAACC,OAAO,IAC1CV,YAAY,CAACW,MAAM,CAACD,OAAO,EAAE,YAAY,EAAE,GAAG,CAChD,CAAC;;UAED;UACA,MAAMG,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;UAC/BD,QAAQ,CAACE,MAAM,CAAC,QAAQ,EAAE,IAAIC,IAAI,CAChC,CAACR,UAAU,CAAC,EACZ,UAAUS,IAAI,CAACC,GAAG,CAAC,CAAC,MAAM,EAC1B;YAAEC,IAAI,EAAE;UAAa,CACvB,CAAC,CAAC;UACFN,QAAQ,CAACE,MAAM,CAAC,YAAY,EAAE,IAAIC,IAAI,CACpC,CAACJ,UAAU,CAAC,EACZ,cAAcK,IAAI,CAACC,GAAG,CAAC,CAAC,MAAM,EAC9B;YAAEC,IAAI,EAAE;UAAa,CACvB,CAAC,CAAC;UAEF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,0CAA0CzD,SAAS,EAAE,EAAE;YAClF0D,MAAM,EAAE,MAAM;YACdrB,IAAI,EAAEY;UACR,CAAC,CAAC;UAEF,IAAI,CAACO,QAAQ,CAACG,EAAE,EAAE;YAChB,MAAM,IAAIC,KAAK,CAAC,kBAAkBJ,QAAQ,CAACK,UAAU,EAAE,CAAC;UAC1D;QACF,CAAC,CAAC,OAAO1C,KAAK,EAAE;UACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;QAC3D,CAAC,SAAS;UACRf,YAAY,CAACa,OAAO,GAAG,KAAK;QAC9B;MACF;IACF,CAAC;IAED,IAAIhB,QAAQ,IAAID,SAAS,EAAE;MACzBQ,YAAY,CAAC,CAAC;MACdD,eAAe,GAAGuD,WAAW,CAACnC,gBAAgB,EAAE,IAAI,CAAC,CAAC,CAAC;IACzD;IAEA,OAAO,MAAM;MACXN,WAAW,CAAC,CAAC;IACf,CAAC;EACH,CAAC,EAAE,CAACrB,SAAS,EAAEC,QAAQ,EAAEI,MAAM,CAAC,CAAC;EAEjC,oBACEP,OAAA;IACEiE,GAAG,EAAE5D,QAAS;IACd6D,QAAQ;IACRC,WAAW;IACXC,KAAK;IACLC,KAAK,EAAE;MAAEC,OAAO,EAAE;IAAO,CAAE;IAC3B,eAAY;EAAc;IAAAC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAC3B,CAAC;AAEN,CAAC;AAACtE,EAAA,CAhHIH,YAAY;AAAA0E,EAAA,GAAZ1E,YAAY;AAkHlB,eAAeA,YAAY;AAAC,IAAA0E,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}