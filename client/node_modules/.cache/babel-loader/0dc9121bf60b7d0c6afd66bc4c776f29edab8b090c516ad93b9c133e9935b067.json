{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Dravya\\\\Expression Tracker(Leela)\\\\Expression_Tracker\\\\client\\\\src\\\\components\\\\ImageCaptureComponent.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport html2canvas from 'html2canvas';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst ImageCapture = ({\n  sessionId,\n  isActive\n}) => {\n  _s();\n  const videoRef = useRef(null);\n  const capturingRef = useRef(false);\n  const [stream, setStream] = useState(null);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    let captureInterval;\n    const startCapture = async () => {\n      try {\n        const mediaStream = await navigator.mediaDevices.getUserMedia({\n          video: {\n            width: {\n              ideal: 640\n            },\n            height: {\n              ideal: 480\n            }\n          }\n        });\n        setStream(mediaStream);\n        if (videoRef.current) {\n          videoRef.current.srcObject = mediaStream;\n        }\n      } catch (error) {\n        console.error('Error accessing webcam:', error);\n        setError('Failed to access webcam');\n      }\n    };\n    const stopCapture = () => {\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n        setStream(null);\n      }\n      if (captureInterval) {\n        clearInterval(captureInterval);\n      }\n    };\n    const captureAndUpload = async () => {\n      if (!capturingRef.current && sessionId) {\n        capturingRef.current = true;\n        try {\n          // Ensure video is ready\n          if (!videoRef.current || !videoRef.current.readyState === videoRef.current.HAVE_ENOUGH_DATA) {\n            throw new Error('Video stream not ready');\n          }\n\n          // Capture webcam\n          const webcamCanvas = document.createElement('canvas');\n          webcamCanvas.width = videoRef.current.videoWidth;\n          webcamCanvas.height = videoRef.current.videoHeight;\n          const webcamCtx = webcamCanvas.getContext('2d');\n          webcamCtx.drawImage(videoRef.current, 0, 0);\n\n          // Capture screenshot\n          const screenCanvas = await html2canvas(document.body, {\n            scale: 0.5,\n            logging: false,\n            useCORS: true,\n            ignoreElements: element => {\n              return element.tagName === 'VIDEO' || element.classList.contains('no-screenshot');\n            }\n          });\n\n          // Convert to blobs with compression\n          const webcamBlob = await new Promise(resolve => webcamCanvas.toBlob(resolve, 'image/jpeg', 0.7));\n          const screenBlob = await new Promise(resolve => screenCanvas.toBlob(resolve, 'image/jpeg', 0.7));\n\n          // Create FormData and upload\n          const formData = new FormData();\n          formData.append('webcam', new File([webcamBlob], `webcam_${Date.now()}.jpg`, {\n            type: 'image/jpeg'\n          }));\n          formData.append('screenshot', new File([screenBlob], `screenshot_${Date.now()}.jpg`, {\n            type: 'image/jpeg'\n          }));\n          const response = await fetch(`http://localhost:5000/upload?sessionId=${sessionId}`, {\n            method: 'POST',\n            body: formData\n          });\n          if (!response.ok) {\n            throw new Error(`Upload failed: ${response.statusText}`);\n          }\n          console.log('Successfully captured and uploaded images for session:', sessionId);\n        } catch (error) {\n          console.error('Error capturing/uploading images:', error);\n          setError(error.message);\n        } finally {\n          capturingRef.current = false;\n        }\n      }\n    };\n\n    // Only start capturing if we have both sessionId and isActive\n    if (isActive && sessionId) {\n      console.log('Starting capture with sessionId:', sessionId);\n      startCapture();\n      captureInterval = setInterval(captureAndUpload, 5000);\n    } else {\n      console.log('Stopping capture. isActive:', isActive, 'sessionId:', sessionId);\n      stopCapture();\n    }\n    return () => {\n      stopCapture();\n    };\n  }, [sessionId, isActive, stream]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      muted: true,\n      style: {\n        display: 'none'\n      },\n      \"data-testid\": \"webcam-video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 124,\n      columnNumber: 7\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error-message\",\n      style: {\n        display: 'none'\n      },\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true);\n};\n_s(ImageCapture, \"HbXO45HEmQpAYwevb1BKAVBgFg8=\");\n_c = ImageCapture;\nexport default ImageCapture;\nvar _c;\n$RefreshReg$(_c, \"ImageCapture\");","map":{"version":3,"names":["React","useEffect","useRef","useState","html2canvas","jsxDEV","_jsxDEV","Fragment","_Fragment","ImageCapture","sessionId","isActive","_s","videoRef","capturingRef","stream","setStream","error","setError","captureInterval","startCapture","mediaStream","navigator","mediaDevices","getUserMedia","video","width","ideal","height","current","srcObject","console","stopCapture","getTracks","forEach","track","stop","clearInterval","captureAndUpload","readyState","HAVE_ENOUGH_DATA","Error","webcamCanvas","document","createElement","videoWidth","videoHeight","webcamCtx","getContext","drawImage","screenCanvas","body","scale","logging","useCORS","ignoreElements","element","tagName","classList","contains","webcamBlob","Promise","resolve","toBlob","screenBlob","formData","FormData","append","File","Date","now","type","response","fetch","method","ok","statusText","log","message","setInterval","children","ref","autoPlay","playsInline","muted","style","display","fileName","_jsxFileName","lineNumber","columnNumber","className","_c","$RefreshReg$"],"sources":["C:/Users/Dravya/Expression Tracker(Leela)/Expression_Tracker/client/src/components/ImageCaptureComponent.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport html2canvas from 'html2canvas';\r\n\r\nconst ImageCapture = ({ sessionId, isActive }) => {\r\n  const videoRef = useRef(null);\r\n  const capturingRef = useRef(false);\r\n  const [stream, setStream] = useState(null);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    let captureInterval;\r\n\r\n    const startCapture = async () => {\r\n      try {\r\n        const mediaStream = await navigator.mediaDevices.getUserMedia({ \r\n          video: {\r\n            width: { ideal: 640 },\r\n            height: { ideal: 480 }\r\n          }\r\n        });\r\n        setStream(mediaStream);\r\n        if (videoRef.current) {\r\n          videoRef.current.srcObject = mediaStream;\r\n        }\r\n      } catch (error) {\r\n        console.error('Error accessing webcam:', error);\r\n        setError('Failed to access webcam');\r\n      }\r\n    };\r\n\r\n    const stopCapture = () => {\r\n      if (stream) {\r\n        stream.getTracks().forEach(track => track.stop());\r\n        setStream(null);\r\n      }\r\n      if (captureInterval) {\r\n        clearInterval(captureInterval);\r\n      }\r\n    };\r\n\r\n    const captureAndUpload = async () => {\r\n      if (!capturingRef.current && sessionId) {\r\n        capturingRef.current = true;\r\n        try {\r\n          // Ensure video is ready\r\n          if (!videoRef.current || !videoRef.current.readyState === videoRef.current.HAVE_ENOUGH_DATA) {\r\n            throw new Error('Video stream not ready');\r\n          }\r\n\r\n          // Capture webcam\r\n          const webcamCanvas = document.createElement('canvas');\r\n          webcamCanvas.width = videoRef.current.videoWidth;\r\n          webcamCanvas.height = videoRef.current.videoHeight;\r\n          const webcamCtx = webcamCanvas.getContext('2d');\r\n          webcamCtx.drawImage(videoRef.current, 0, 0);\r\n          \r\n          // Capture screenshot\r\n          const screenCanvas = await html2canvas(document.body, {\r\n            scale: 0.5,\r\n            logging: false,\r\n            useCORS: true,\r\n            ignoreElements: (element) => {\r\n              return element.tagName === 'VIDEO' || element.classList.contains('no-screenshot');\r\n            }\r\n          });\r\n          \r\n          // Convert to blobs with compression\r\n          const webcamBlob = await new Promise(resolve => \r\n            webcamCanvas.toBlob(resolve, 'image/jpeg', 0.7)\r\n          );\r\n          const screenBlob = await new Promise(resolve => \r\n            screenCanvas.toBlob(resolve, 'image/jpeg', 0.7)\r\n          );\r\n          \r\n          // Create FormData and upload\r\n          const formData = new FormData();\r\n          formData.append('webcam', new File(\r\n            [webcamBlob], \r\n            `webcam_${Date.now()}.jpg`, \r\n            { type: 'image/jpeg' }\r\n          ));\r\n          formData.append('screenshot', new File(\r\n            [screenBlob], \r\n            `screenshot_${Date.now()}.jpg`, \r\n            { type: 'image/jpeg' }\r\n          ));\r\n          \r\n          const response = await fetch(`http://localhost:5000/upload?sessionId=${sessionId}`, {\r\n            method: 'POST',\r\n            body: formData,\r\n          });\r\n\r\n          if (!response.ok) {\r\n            throw new Error(`Upload failed: ${response.statusText}`);\r\n          }\r\n          \r\n          console.log('Successfully captured and uploaded images for session:', sessionId);\r\n        } catch (error) {\r\n          console.error('Error capturing/uploading images:', error);\r\n          setError(error.message);\r\n        } finally {\r\n          capturingRef.current = false;\r\n        }\r\n      }\r\n    };\r\n\r\n    // Only start capturing if we have both sessionId and isActive\r\n    if (isActive && sessionId) {\r\n      console.log('Starting capture with sessionId:', sessionId);\r\n      startCapture();\r\n      captureInterval = setInterval(captureAndUpload, 5000);\r\n    } else {\r\n      console.log('Stopping capture. isActive:', isActive, 'sessionId:', sessionId);\r\n      stopCapture();\r\n    }\r\n\r\n    return () => {\r\n      stopCapture();\r\n    };\r\n  }, [sessionId, isActive, stream]);\r\n\r\n  return (\r\n    <>\r\n      <video\r\n        ref={videoRef}\r\n        autoPlay\r\n        playsInline\r\n        muted\r\n        style={{ display: 'none' }}\r\n        data-testid=\"webcam-video\"\r\n      />\r\n      {error && <div className=\"error-message\" style={{ display: 'none' }}>{error}</div>}\r\n    </>\r\n  );\r\n};\r\n\r\nexport default ImageCapture;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}